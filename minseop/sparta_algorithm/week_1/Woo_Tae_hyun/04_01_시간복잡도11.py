#1. array의 길이 X array의 길이 X 비교 연산 1번
# 만큼의 시간이 필요합니다. 여기서 array(입력값)의 길이는 보통 N이라고 표현합니다.
# 그러면 위의 시간을 다음과 같이 표현할 수 있습니다.
# N x N
# 그러면 우리는 이제 이 함수는 N^2 만큼의 시간이 걸렸겠구나! 라고 말할 수 있습니다.

# N * 1 = N 만큼
# 알고리즘은 성능이 항상 동일한게 아니라 입력값에 분포에 따라서 성능이 변화할 수 있다.
# 입력값이 좋을때 소요되는 연산량 :1
# 안 좋을때 소요되는 연산량 : N
# 빅오 표기법으로는 O(N)
# 빅 오메가 표기법으로는 오메가(1)
# 대부분의 입력값은 최선일 경우가 없음.
# 최악의 경우를 대비해야함.
# 그렇기 때문에 빅오 표기법으로 항상 분석함.
# 입력값에 비례해서 얼마나 늘어날지 파악해보자. 1? N? N^2?
# 공간복잡도 보다는 시간 복잡도를 더 줄이기 위해 고민하자.
# 최악의 경우에 시간이 얼마나 소요될지(빅오 표기법)에 대해 고민하자.


input = [3, 5, 6, 1, 2, 4]


def find_max_num(array):
    for num in array:              # array 의 길이만큼 아래 연산이 실행
        for compare_num in array:  # array 의 길이만큼 아래 연산이 실행
            if num < compare_num:  # 비교 연산 1번 실행
                break
        else:
            return num


result = find_max_num(input)
print("정답 = 6 / 현재 풀이 값 = ", find_max_num([3, 5, 6, 1, 2, 4]))
print("정답 = 6 / 현재 풀이 값 = ", find_max_num([6, 6, 6]))
print("정답 = 1888 / 현재 풀이 값 = ", find_max_num([6, 9, 2, 7, 1888]))